# Barista

## Overview

Barista enables you to generate code for any language.

With the expressive syntax and powerful flexibility of Barista you can quickly accomplish many code generation tasks, such as writing boiler-plate object wrapper code for several targets simultaneously.

Under the engines directory you can add new targets:
/Users/cat/barista/engines/myTarget/

## Input JSON Schema

Example JSON input file:

~~~
{
	"type": "objectTemplate",
	"name": "timestep_image_map",
	"jsName": "ImageMap",
	"hasConstructor": true,
	"constructorArgc": 12,
	"headers": [
		"core/timestep/timestep_image_map.h"
	],
	"autoProperties": [
		{
			"type": "int",
			"name": "x"
		},
		...
	]
}
~~~

An objectTemplate is a json file describing a C object that
should be wrapped in JavaScript.  It can have three types of
functionality:

+ methods:

Methods are described as:

~~~
      {
          "name": "aJavascriptMethod",
          "argCount": 1
      }
~~~

They make the promise that a C method matching the method.bar
template is implemented elsewhere.

 + properties:

An object description may have one or more "properties".  Properties
correspond to getter/setter object properties in JavaScript.

An object description that specifies properties is making the promise
that the getter and/or setter for this property is implemented elsewhere
in their C source.

Properties can be specified in two ways - either a String name, which
means that the property is readable and writable, or an object

~~~
     {
         name: "propertyName",
         readOnly: true|false
     }
~~~

This method will normalize them to all be of the second style.

They make the promise that a C method matching the property.bar
template is implemented elsewhere.

 + autoProperties:

autoProperties are properties specified on an object
description that can have their implementations automatically
generated.  Autoproperty specs look like:

~~~
     {
         "type": "double", //type is specified in engineName/types.js
         "name": "myProperty"
     }
~~~

They have wrappers generated by the engine/autoProperty.bar template

objecTemplates also have the following properties:

+ name: the name of the C backing of the object

+ jsName: the name that should be exported to JavaScript

+ headers: an array of headers that should be included in the generated C source

+ hasConstructor: true|false.  If an objectTemplate has a constructor, it is assumed that it is correctly implemented elsewhere.

+ constructorArgc: if there is a constructor, the number of arguments to it

## Target Structure

Under the /myTarget/ folder add these required files:

### /myTarget/types.js

Export a list of types:

~~~
exports.types = {
    'bool': 'Boolean',
    'int': 'Int32',
    'unsigned int': 'Int',
    'long': 'Int',
    'short': 'Int',
    'char': 'Int',
    'double': 'Number',
    'float': 'Float',
    'char*': 'String',
    'char *': 'String',
    'rgba': 'String'
};
~~~

The strings on the right are the internal names of the target-specific names on the left.

### /myTarget/header.bar

This is a top-level file that references other files.  This produces a header file.

Use `{NAME}` for upper-case file name, and `{name}` for lower-case.

Use `{methods}` to reference `method.bar`.

Use `{properties}` to reference `property.bar`.

The output file will be `{name}_template.gen.h`.

### /myTarget/objectTemplate.bar

This is a top-level file that references other files.  This produces a source file.

Use `{#headers}` followed by `{/headers}` to produce one line for each header.  The header names are represented by `{.}`.

For example:

~~~
{#headers}
#include "{.}"
{/headers}
~~~

Similarly you can do the same for other bar files: `{#templateNames}` ... `{/templateNames}`.

To drop in other sub-files, reference them by name:

~~~
{autoProperties}

{methodArray}
~~~

### /myTarget/customGetters/

Name the .bar files under this path after the internal names like `String` or `Int32`.

### /myTarget/customSetters/

Name the .bar files under this path after the internal names like `String` or `Int32`.

